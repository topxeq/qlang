package qlang

import (
	"fmt"

	"github.com/topxeq/qlang/exec"
	"github.com/topxeq/text/tpl/interpreter.util"
)

// -----------------------------------------------------------------------------

func (p *Compiler) function(e interpreter.Engine) {

	fnb, _ := p.gstk.Pop()
	variadic := p.popArity()
	arity := p.popArity()
	args := p.gstk.PopFnArgs(arity)
	instr := p.Code.Reserve()
	fnctx := p.Fnctx
	p.exits = append(p.exits, func() {
		start, end, symtbl := p.clFunc(e, "doc", fnb, fnctx, args)
		instr.Set(exec.Func(nil, start, end, symtbl, args, variadic != 0))
	})
}

func (p *Compiler) xfunction(e interpreter.Engine) {
	fmt.Printf("hhhh\n")
	fnb, _ := p.gstk.Pop()
	variadic := p.popArity()
	arity := p.popArity()
	args := p.gstk.PopFnArgs(arity)
	instr := p.Code.Reserve()
	fnctx := p.Fnctx
	p.exits = append(p.exits, func() {
		start, end, symtbl := p.clFunc(e, "doc", fnb, fnctx, args)
		instr.Set(exec.Func(nil, start, end, symtbl, args, variadic != 0))
	})

	fn := &functionInfo{
		args:     args,
		fnb:      fnb,
		variadic: variadic != 0,
	}
	p.gstk.Push(fn)
}

func (p *Compiler) anonymFn(e interpreter.Engine) {

	fnb, _ := p.gstk.Pop()
	instr := p.Code.Reserve()
	fnctx := p.Fnctx
	p.exits = append(p.exits, func() {
		start, end, symtbl := p.clFunc(e, "doc", fnb, fnctx, nil)
		instr.Set(exec.AnonymFn(start, end, symtbl))
	})
}

func (p *Compiler) fnReturn(e interpreter.Engine) {

	arity := p.popArity()
	p.Code.Block(exec.Return(arity))
}

// Done completes all exit functions generated by `Cl`.
//
func (p *Compiler) Done() {

	for {
		n := len(p.exits)
		if n == 0 {
			break
		}
		onExit := p.exits[n-1]
		p.exits = p.exits[:n-1]
		onExit()
	}
}

func (p *Compiler) fnDefer(e interpreter.Engine) {

	src, _ := p.gstk.Pop()
	instr := p.Code.Reserve()
	fnctx := p.Fnctx
	p.exits = append(p.exits, func() {
		start, end := p.clBlock(e, "expr", src, fnctx)
		p.codeLine(src)
		instr.Set(exec.Defer(start, end))
	})
}

func (p *Compiler) fnRecover() {

	p.Code.Block(exec.Recover)
}

func (p *Compiler) clFunc(
	e interpreter.Engine, g string, src interface{},
	parent *FuncCtx, args []string) (start, end int, symtbl map[string]int) {

	ctx := newFuncCtx(parent, args)
	old := p.Fnctx
	p.Fnctx = ctx
	start, end = p.cl(e, g, src)
	symtbl = ctx.Symtbl
	p.Fnctx = old
	return
}

func (p *Compiler) clBlock(
	e interpreter.Engine, g string, src interface{}, parent *FuncCtx) (start, end int) {

	old := p.Fnctx
	p.Fnctx = parent
	start, end = p.cl(e, g, src)
	p.Fnctx = old
	return
}

func (p *Compiler) cl(e interpreter.Engine, g string, src interface{}) (start, end int) {

	start = p.Code.Len()
	if src != nil {
		if err := e.EvalCode(p, g, src); err != nil {
			panic(err)
		}
	}
	end = p.Code.Len()
	return
}

// -----------------------------------------------------------------------------
